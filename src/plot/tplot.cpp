#include "tplot.h"

#include <fstream>

#include <debug.h>
#include <math.h>
#include <tmathtools.h>
#include <iomanip>
#include <timetools.h>
#include <algorithm>
#include <unistd.h>
#include <sys/wait.h>
#include <errno.h>
#include <string.h>

#include <tgridfunction.h>
#include <tfunctions.h>
#include <tinterval.h>
#include <filetools.h>

namespace P4th {

  template<class TYPE> 
  tPlot<TYPE>::tPlot() :
    options(new Options()) , scriptstream(&std::cout)

  {

    this->ResetOptions();
  }
  
  template<class TYPE> 
  tPlot<TYPE>::~tPlot()
  {
    if ( _scriptstream.is_open() )
      _scriptstream.close();
  }

  template <class TYPE>
  Options *tPlot<TYPE>::ResetOptions() {
    _stringOpt::set(Opts(), "baseDir", "/tmp");
    _stringOpt::set(Opts(), "baseName", "/mthplot");
    _stringOpt::set(Opts(), "separator", "|");
    _stringOpt::set(Opts(), "fontPath", "./fonts");
    _stringOpt::set(Opts(), "fontName", "liberation");
    _stringOpt::set(Opts(), "type",  "X11"); // in {pdf, x11, ps, gif, png, tff}
    _boolOpt::set(Opts(), "keepFiles",  "false");
    _doubleOpt::set(Opts(), "fontSize",  10.0);
    _doubleOpt::set(Opts(), "pitch",  60.0);
    _doubleOpt::set(Opts(), "yaw",  30.0);
    _intOpt::set(Opts(), "countorCount", 10);

    _intOpt::set(Opts(), "labelMaxLength",  17);
    _intOpt::set(Opts(), "lineWidth", 4);

    _boolOpt::set(Opts(), "showHidden",  true);
    _boolOpt::set(Opts(), "showContours",  true);

    _strVec colors;
    _strVecOpt::set(Opts(), "colors" , colors);
    
    _strVec labelPositions;
    labelPositions.push_back("left top");
    labelPositions.push_back("center top");
    labelPositions.push_back("right top");
    labelPositions.push_back("left bottom");
    labelPositions.push_back("center bottom");
    labelPositions.push_back("right bottom");
    /*
    labelPositions.push_back("right center");
    labelPositions.push_back("left center");
    */
    _strVecOpt::set(Opts(), "labelPositions" , labelPositions);
    return this->Opts();
  }
  
  template <class TYPE>
  string tPlot<TYPE>::GetTextColor(unsigned int ith) const {
    _strVec colors = _strVecOpt::get(Opts(), "colors");
    if ( ith > 0 && ith - 1 < colors.size()) {
      return colors[ith-1];
    }
    return "lt " + STLStringTools::AsString(ith);
  }

  template <class TYPE>
  string tPlot<TYPE>::GetLineColor(unsigned int ith) const {
    _strVec colors = _strVecOpt::get(Opts(), "colors");
    if ( ith > 0 && ith - 1 < colors.size()) {
      return colors[ith-1];
    }
    return STLStringTools::AsString(ith);
  }

  template <class TYPE>
  string tPlot<TYPE>::GetLabelPosition(unsigned int ith) {
    _strVec positions = _strVecOpt::get(Opts(), "labelPositions");
    assert(positions.size() > 0);

    ith = (ith - 1) % positions.size();
    return positions[ith];
  }

  template <class TYPE>
  void tPlot<TYPE>::Plot(string heading, string labelstr, const _fs *funcs)
  {
    try {
      this->PlotBefore();
      this->PlotDo(heading, labelstr, funcs);
    } catch (...) { 
      this->PlotAfter();
      throw;
    }
    this->PlotAfter();
  }
  
  template <class TYPE>
  void tPlot<TYPE>::PlotBefore()
  {
    dim = -1;
    min = 1.00000 / tFunction0<TYPE>::Epsilon();
    max = -min;

    files.clear();
    
    this->initdos.clear();
    this->plotdos.clear();
  }

  template <class TYPE>
  void tPlot<TYPE>::PlotAfter()
  {
    if (! _boolOpt::get(Opts(), "keepFiles")) {
      for( cStrVecee it = files.begin() ; it < files.end(); it++) {
	FileTools::Delete(*it);
      }
    }
  }

  template <class TYPE>
  void tPlot<TYPE>::PlotDo( string heading, string labelstr, const _fs *funcs )
  {

    this->dim = this->intervals.size();
    _strVec labels = STLStringTools::Split(labelstr, _stringOpt::get(Opts(), "separator"));
    for (int i = labels.size() ; i < funcs->GetSize() ; i++) {
      labels.push_back("f_" + STLStringTools::AsString(i));
    }
    std::cout << labels.size() << std::endl << std::endl;
    string tmp;

    string outputfile = FileTools::SafeFilename( _stringOpt::get(Opts(), "baseDir") + "/" ,  
						 _stringOpt::get(Opts(), "baseName") , 
						 _stringOpt::get(Opts(), "type") );
    
    funcs->ForEvery( &this->tPlot<TYPE>::WriteData , this );

    std::ofstream dest;
    string gpbase = FileTools::SafeFilename(_stringOpt::get(Opts(), "baseDir") + "/",
					    _stringOpt::get(Opts(), "baseName"), "gp");

    OpenTextFile( dest , 
		  gpbase , 
		  "Cannot open outputfile (" + gpbase + ")" ); 

    files.push_back(gpbase);
    this->SetScriptFile( dest );
    this->AddInitDo( "## Auto Generated GnuPlot Script" );
    this->AddInitDo( "## Generated by Mth" );
    
    this->WriteInitDos();
    
    this->AddPlotDo( (string)"set title \""  
		    //		    + "Plot (using gnuplot) of " + heading + "\"");
		    + heading + "\"");

    
    this->AddPlotDo( "set size 1,1" );

    if ( intervals.size() > 0 )
      this->AddPlotDo( (string)"set xrange ["
		      + STLStringTools::AsString( intervals[0].GetLower() , 10 , '.' ) 
		      + ":" 
		       + STLStringTools::AsString( intervals[0].GetUpper() , 10 , '.' ) 
		      + "]" ); 
    tmp = " yrange ";
    if ( dim > 1 ) {
	if ( intervals.size() >= 1 )
	  this->AddPlotDo( (string)"set yrange ["
			  + STLStringTools::AsString( intervals[1].GetLower() , 10 , '.' ) 
			  + ":" 
			  + STLStringTools::AsString( intervals[1].GetUpper() , 10 , '.' ) 
			  + "]" ); 
	tmp = " zrange ";
      }

    
    this->AddPlotDo( (string)"set " + tmp +  " [" 
		     + STLStringTools::AsString( min - 0.1 * 
							 ( tMathTools<TYPE>::Abs( min ) + 
							   ( max - min ) ) , 10 , '.' ) 
		    + ":" 
		    + STLStringTools::AsString( max + 0.1 * 
							 ( tMathTools<TYPE>::Abs( max ) + 
							   ( max - min ) ) , 10 , '.' ) 
		    + "]" ); 

    

    this->AddPlotDo( (string)"set xlabel \"" +  intervals[0].GetSymbol() + "\"" );
    if ( intervals.size() >= 2 )
      {
	this->AddPlotDo( (string)"set ylabel \"" +  intervals[1].GetSymbol() + "\"" );
	//	this->AddPlotDo( (string)"set zlabel \"" +  heading + "\"" );
      }

    if (dim > 1)  {
      this->AddPlotDo( "set origin 0.0,0.0" );
      this->AddPlotDo( (string)"set surface" );
      this->AddPlotDo( (string)"set view " + 
		       STLStringTools::AsString(_doubleOpt::get(Opts(), "pitch" )) + "," +
		       STLStringTools::AsString(_doubleOpt::get(Opts(), "yaw" )) + ",");
      if (_boolOpt::get(Opts(), "showHidden")) {
	this->AddPlotDo( (string)"unset hidden3d" );
      } else {
	this->AddPlotDo( (string)"set hidden3d" );
      }
      if (_boolOpt::get(Opts(), "showContours")) {
	TYPE delta = (TYPE)(round(max) - round(min)) 
	  / (TYPE)(_intOpt::get(Opts(), "countorCount"));
	this->AddPlotDo( (string)"set dgrid3d" );
	this->AddPlotDo( (string)"set contour base" );
	this->AddPlotDo( (string)"set clabel" );
	//	this->AddPlotDo( (string)"set cntrparam level auto 5" ); 
	this->AddPlotDo( "set cntrparam cubicspline");
	this->AddPlotDo( "set cntrparam levels incremental " +
			 STLStringTools::AsString(round(min)) + ", " +
			 STLStringTools::AsString(delta) + ", " +
			 STLStringTools::AsString(round(max)) );

	this->AddPlotDo( "show contour");
      } else {
	this->AddPlotDo( (string)"unset contour" );
      }
    }

    string outputfilepath = "";
    string outputfilename = outputfile;
    string outputext = _stringOpt::get(Opts(), "type");
    int slashi = outputfile.find_last_of( '/' );
    if ( slashi  >= 0 )  
      {
	outputfilepath = STLStringTools::LeftOfExc( outputfile , slashi );
	outputfilename = STLStringTools::RightOfInc( outputfile , slashi + 1 );
      }

    string fontname = _stringOpt::get(Opts(), "fontName");
    string fontpath = _stringOpt::get(Opts(), "fontPath");
    double fontsize = _doubleOpt::get(Opts(), "fontSize");
    if ( outputext == (string)"gif" )
      {
	this->AddPlotDo( (string)"set terminal gif enhanced size 1024,1024 font \"" +  
			fontpath + "/" + fontname + ".ttf\" " 
			+ STLStringTools::AsString( (int)(fontsize + 0.49999) ) );
      }
    if ( outputext == (string)"png" )
      {
	this->AddPlotDo( (string)"set terminal png enhanced size 1024,1024 font \"" + 
			fontpath + "/" + fontname + ".ttf\" " 
			+ STLStringTools::AsString( (int)(fontsize + 0.49999) ) );
      }
    if ( outputext == (string)"pdf" )
      this->AddPlotDo( (string)"set terminal pdf enhanced color font \"" + fontname + "," 
		      + STLStringTools::AsString( (int)(fontsize + 0.49999) ) + "\"" + 
		      " size 25cm,25cm" );
    if ( outputext == (string)"ps" )
      this->AddPlotDo( (string)"set terminal postscript enhanced color \"" + fontname + "\" " 
		      + STLStringTools::AsString( (int)(fontsize + 0.49999) ) );
    if ( outputext == (string)"tex" )
      this->AddPlotDo( (string)"set terminal eepic " + 
		      STLStringTools::AsString( (int)(fontsize + 0.49999) ) );
    if ( outputext == (string)"X11" )
      this->AddPlotDo( (string)"set terminal X11" );
    else
      this->AddPlotDo( (string)"set output '" 
		      + outputfile + "'" );

    this->AddPlotDo( (string)"unset multiplot" );
    this->AddPlotDo( "set key outside" );
     string label;
     string plotcmd,plotfmt;
     _strVec allPlots;
     if ( dim > 1 )
       {
	 plotcmd = "splot  ";
	 plotfmt = " using 1:2:3 ";
       } else {
	 plotcmd = "plot ";
	 plotfmt = " using 1:2 ";
       }
     int labelMaxLength = _intOpt::get(Opts(), "labelMaxLength");
     for ( unsigned int plotctr = 0 ; plotctr < funcs->GetSize() ; plotctr++ )
       {
	 label = labels[plotctr];
	 if ( label.size() > labelMaxLength )
	   label = label.substr( 0 , ( labelMaxLength - 3 ) / 2 ) + 
	     "..." + 
	     label.substr( label.length() - ( labelMaxLength - 3 ) / 2 , 
			   ( labelMaxLength - 3 ) / 2 );
	 label = "\"" + label  + "\"";
	 
	 allPlots.push_back( " \"" + files[plotctr] + "\"" + 
			     plotfmt +
			     + " title " + label + 
			     + " with lines lt " + this->GetLineColor(plotctr+1)  
			     + " lw " + STLStringTools::AsString( _intOpt::get(Opts(), "lineWidth" ) ) );
       }
    
     this->AddPlotDo( plotcmd + " " + STLStringTools::Join(allPlots, ",\\\n\t" ));
     if ( outputext == (string)"X11" )
       this->AddPlotDo( (string)"pause -1" );

    this->WritePlotDos();
    if ( dest.is_open() )
      dest.close();

    if ( system( NULL ) == 0 )
      {
	throw aException(tPlot<TYPE>, "Error creating ps file for " 
		  + heading 
		  + "(this is not an user error)." ); 
      }

    if ( system( (const char *)((string)"/usr/bin/gnuplot " + gpbase ).c_str() ) == -1 )
      {
	int errnr = errno;
	perror( "execl" );
	std::cerr << strerror( errnr ) << std::endl;
	_DBTHROW( (string)"Error creating file for " 
		  + heading
		  + "(this is not an user error)." ); 
      }
    this->AddFile( outputfile );
    

  }


  template<class TYPE> 
  std::ofstream &tPlot<TYPE>::OpenTextFile( std::ofstream &dest , 
						   string filename ,
						   const string &throwstring ) const
  {
    if ( dest.is_open() )
      if ( throwstring != (string)"" )
	throw aException(tPlot<TYPE>, throwstring );
      else
	throw aException(tPlot<TYPE> , "Error : Could not open '" + filename + "'" ); 
    
    dest.open( filename.c_str() , std::ios_base::trunc | std::ios_base::out );
    if ( ! dest.is_open() )
      if ( throwstring != (string)"" )
	throw aException(tPlot<TYPE>,  throwstring );
      else
	throw aException(tPlot<TYPE> , (string)"Error : Could not open '" + filename + "'" ); 
    return dest;
  }

  template<class TYPE> 
  const tFunction0<TYPE> *tPlot<TYPE>::WriteData( const _f *f , int ith,  Polymorphic *__this )
  {
    tPlot<TYPE> *_this = dynamic_cast<tPlot<TYPE> *>(__this);
    assert(_this != NULL);
    assert(_this->intervals.size() > 0);
    
    tnmmatrix<TYPE> xaxis( 1 , 1 , 0.0 );
    xaxis.SafeCopy( (tnmmatrix<TYPE>)(_this->intervals[0] ) );
    
    tnmmatrix<TYPE> yaxis( 1 , 1 , 0.0 );
    if ( _this->dim > 1 )
      yaxis.SafeCopy( (tnmmatrix<TYPE>)_this->intervals[1] );

    tnmmatrix<TYPE> x( _this->dim , 1 );
    TYPE ytmp;

    std::string filepath = _stringOpt::get(_this->Opts(), "baseDir") + "/" + "mth_data_f_" + STLStringTools::AsString( ith ) + 
      "_" + STLStringTools::AsString((unsigned int)TimeTools::Current2Time());
    _this->files.push_back(filepath);
    std::ofstream dest;
    _this->OpenTextFile( dest , filepath , "Cannot open outputfile (" +  filepath + ")" ); 
    
    for ( int yctr = 1 ; yctr <= yaxis.GetRows() ; yctr++ ) 
      {
	if ( _this->dim > 1 )
	  x( 2 ,1 ) = yaxis.Get( yctr ,1 );
	for ( int xctr = 1 ; xctr <= xaxis.GetRows() ; xctr++ ) 
	  {
	    x( 1 ,1 ) = xaxis.Get( xctr ,1 );
	    
	    std::operator<<( dest , STLStringTools::AsString( x.Get( 1 ,1 ) ) );
	    if ( _this->dim > 1 )
	      std::operator<<( dest , "\t" + STLStringTools::AsString( x.Get( 2 ,1 ) ) );
	    std::operator<<( dest , "\t" + STLStringTools::AsString( f->y( ytmp , x ) ) ); 
	    dest << std::endl;
	    if ( ytmp < _this->min )
	      _this->min = ytmp;
	    if ( ytmp > _this->max )
	      _this->max = ytmp;
	  }
	dest << std::endl;
      }
    if ( dest.is_open() )
      dest.close();
    return 0L;
  }

  template<class TYPE> 
  std::ostream &tPlot<TYPE>::Dump( std::ostream &dest , P4th::string lm ) const 
  {
    return dest;
  }

  template<class TYPE>
  std::ostream &tPlot<TYPE>::WriteInitDos()
  {
    for ( int i = 0 ; i < initdos.size() ; i++ )
      (*scriptstream) << initdos[i] << std::endl;
  }

  template<class TYPE>
  std::ostream &tPlot<TYPE>::WritePlotDos()
  {
    (*scriptstream) << "## New tPlot" << std::endl;
    for ( int i = 0 ; i < plotdos.size() ; i++ )
      (*scriptstream) << plotdos[i] << std::endl;
    (*scriptstream) << std::endl;
  }

  template<class TYPE> 
  std::ofstream &tPlot<TYPE>::OpenTextFile( std::ofstream &dest , const string &file ) const
  {
    if ( dest.is_open() )
      {
        _DBTHROW("int tPlot<TYPE,DIM>::OpenTextFile( std::ostream &dest , const Chars &file ) : dest.is_open()" );
      }
    dest.open( file );
    if ( ! dest.is_open() )
        _DBTHROW("int tPlot<TYPE,DIM>::OpenTextFile( std::ostream &dest , const Chars &file ) : ! dest.is_open()" );
    return dest;
  }

  template<class TYPE>
  std::ofstream &tPlot<TYPE>::CloseFile( std::ofstream &dest ) const
  {
    if ( ! dest.is_open() )
      {
        _DBTHROW("int OpenFile( std::ostream &dest , const Chars &file ) : File is not open" );
      }
    dest.close();
    return dest;
  }

}

template class P4th::tPlot<float>;
template class P4th::tPlot<double>;






